#include <ros/ros.h>
#include <std_msgs/String.h>
#include <geometry_msgs/Twist.h>
#include <sensor_msgs/image_encodings.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/Image.h>
#include <sstream>
#include <iostream>
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>

using namespace std;
using namespace cv;

static const std::string OPENCV_WINDOW = "Camera";
image_transport::Publisher image_pub;

//global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;
ros::Subscriber sub;

//function declarations
void processVideo(char* videoFilename);


int option = 1;

void drawOptFlowMap(const Mat& flow, Mat& cflowmap, int step,
    double scale, const Scalar& color)
{
  for(int y = 0; y < cflowmap.rows; y += step)
    for(int x = 0; x < cflowmap.cols; x += step)
    {
      const Point2f& fxy = flow.at<Point2f>(y, x);
      line(cflowmap, Point(x,y), Point(cvRound(x+fxy.x), cvRound(y+fxy.y)),
          color);
      circle(cflowmap, Point(x,y), 2, color, -1);
    }
}


bool foobar = true;

void processVideo(char* videoFilename) {
  //create the capture object
  VideoCapture capture(0);
  if(!capture.isOpened()){
    //error in opening the video input
    cerr << "Unable to open video file: " << videoFilename << endl;
    exit(EXIT_FAILURE);
  }
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    //read the current frame
    if(!capture.read(frame)) {
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
      exit(EXIT_FAILURE);
    }
    //update the background model
    pMOG2->apply(frame, fgMaskMOG2);
    //get the frame number and write it on the current frame
    stringstream ss;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
              cv::Scalar(255,255,255), -1);
    ss << capture.get(CAP_PROP_POS_FRAMES);
    string frameNumberString = ss.str();
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
    //show the current frame and the fg masks
    imshow("Frame", frame);
    imshow("FG Mask MOG 2", fgMaskMOG2);
    //get the input from the keyboard
    //keyboard = waitKey( 1000 );

    if(waitKey(1000)>=0)
      break;
    //ros::spinOnce();

  }
  //delete capture object
  capture.release();
}

void gaussian( const sensor_msgs::Image::ConstPtr& msg) {
    //create GUI windows
  namedWindow("Frame");
  namedWindow("FG Mask MOG 2");

  //create Background Subtractor objects
  pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach


  processVideo("/dev/video1");  // THIS IS WHERE WE NEED TO PUT OUR VIDEO READ THISPLSSSSSSSSS

  //destroy GUI windows
  destroyAllWindows();
  return ;
}
void imageCb(const sensor_msgs::Image::ConstPtr& msg)
{
  VideoCapture cap(0);
  if( !cap.isOpened())
    return;
  namedWindow("flow", 1);
  ros::NodeHandle node;
  image_transport::ImageTransport it(node);
  image_pub = it.advertise("/image_converter/output_video", 1);
  cv_bridge::CvImagePtr cv_ptr;
  try
  {
    cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
    //cv_ptr = cv_bridge::toCvCopy(msg, msg->encoding);
  }
  catch (cv_bridge::Exception& e)
  {
    ROS_ERROR("cv_bridge exception: %s", e.what());
    return;
  } 
  // Mat GetImg;
  //swap(GetImg, cv_ptr->image);
  //GetImg.reshape(1,GetImg.rows*GetImg.cols).col(3).setTo(Scalar(120));
  //resize(GetImg, next, Size(GetImg.size().width/5, GetImg.size().height/5) ); 
  Mat prevgray, gray, flow, cflow, frame;
  namedWindow("flow", 1);

  for(;;)
  {
    cap >> frame;
    cvtColor(frame, gray, CV_BGR2GRAY);

    if( prevgray.data )
    {
      calcOpticalFlowFarneback(prevgray, gray, flow, 0.5, 3, 15, 3, 5, 1.2, 0);
      cvtColor(prevgray, cflow, CV_GRAY2BGR);
      drawOptFlowMap(flow, cflow, 16, 1.5, CV_RGB(0, 255, 0));
      imshow("flow", cflow);
    }
    if(waitKey(1000)>=0)
      break;
    std::swap(prevgray, gray);
    if(option == 1)
      break;
    //ros::spinOnce();
  }
  /* if( prev.data ) {
     swap(prev, next);
    cout << prev.size() << " " << next.size() << " " 
         << prev.channels() << " " << next.channels();
    calcOpticalFlowFarneback(prev, next, flow, 0.5, 3, 15, 3, 5, 1.2, 0);
    // Draw an example circle on the video stream

    cout << prev.size() << " " << next.size() << " " 
         << prev.channels() << " " << next.channels();
    Mat cflow;
    cvtColor(prev, cflow, CV_GRAY2BGR);  
    drawOptFlowMap(flow, cflow, 10, 1.5, CV_RGB(0, 255, 0));
    imshow("OpticalFlowFarneback", cflow);  

    // Update GUI Window
    cv::imshow(OPENCV_WINDOW, flow);
    image_pub.publish(cv_ptr->toImageMsg());
  }
  swap(prev, next);

  // Output modified video stream
  foobar = false;
  */

}

void render( const sensor_msgs::Image::ConstPtr & msg ) {
  // cout << "RENDER IT YOURSELF!!!" << endl;
  if( option == 2 )
    imageCb( msg );
  else 
    gaussian(msg );
}

void respondToRequest( const std_msgs::String::ConstPtr & msg ) {
  if( msg->data.c_str()[0] == '1' )
    option = 1;
  if( msg->data.c_str()[0] == '2' )
    option = 2;
}

int main( int argc, char **argv ) {
	ros::init(argc, argv, "motion_detector");
  ros::NodeHandle node;
  ros::Subscriber sub_cam = node.subscribe("/camera/visible/image", 1, render);


/*  void imageCallback(const sensor_msgs::ImageConstPtr& msg)
{
  // ...
}

ros::NodeHandle nh;
image_transport::ImageTransport it(nh);
image_transport::Subscriber sub = it.subscribe("in_image_base_topic", 1, imageCallback);
image_transport::Publisher pub = it.advertise("out_image_base_topic", 1);
image_transport::Subscriber sub = it.subscribe("/camera/visible/image", 1, imageCallback);
image_transport::Publisher pub = it.advertise("/camera/visible/image", 1); */

  sub = node.subscribe("/chatter",1000, respondToRequest);
  cv::namedWindow(OPENCV_WINDOW);
  ros::spin();
  cv::destroyWindow(OPENCV_WINDOW);

  return 0;
}
